В этой домашней работе вам предстоит поработать над поиском в приложении интернет-магазина, изменить класс
SearchEngine
и избавиться от возможности добавления туда дубликатов.

Сделайте это задание в новой ветке «старого» проекта, где выполняли предыдущую домашнюю работу. Выполняйте задание строго по порядку. Пока не сделали предыдущий шаг — не приступайте к следующему.
Задание 1
Сейчас наш класс поискового движка позволяет добавлять в себя дубликаты. Это значит, что время поиска подходящего товара или статьи может занимать много времени. Поэтому уберем возможность добавления дубликатов в класс
SearchEngine
.

Для этого нужно применить
Set
, а так же написать реализацию методов
equals
и
hashCode
для классов, которые добавляются в
SearchEngine
— абстрактного класса
Product
и класса
Article
.

Продуктовая команда решила, что продуктов и статей с одинаковым именем не должно существовать. Значит, в качестве ключа
hashCode
и элемента для сравнения мы можем выбрать поле с именем объекта.

Шаг 1. Замена List на Set
Для начала заменим структуру
List
на структуру
Set
.

Для этого достаточно использовать
HashSet
, так как отсортированности и сохранения порядка добавления не требуется.
После замены структуры и небольших исправлений проект должен работать так же, как и раньше.
Шаг 2. Реализация equals и hashCode для статей и продуктов
Реализуйте в классе статей и в классе продуктов методы
equals
и
hashCode
, которые учитывают только имя статьи или продукта. Остальные поля пока учитывать не нужно.

Попробуйте написать методы вручную, чтобы потренироваться. Также можно воспользоваться автогенерацией методов в IDEA.
Задание 2
Продуктовой команде не понравилась сортировка результатов поиска по имени с помощью натурального сравнения, а также то, что результаты поиска теперь выводятся с именем, что не очень красиво, так как в
Searchable
уже есть вывод имени.

Перепишите тип выдачи результатов поиска.

На этот раз будем выдавать отсортированный
Set
из
Searchable
-элементов.
Сортировку сделаем в следующем порядке: от самого длинного названия (в начале) до самого короткого (в конце).
Если длина названий одинаковая, то сортировать будем в натуральном порядке.
Шаг 1. Замена TreeMap на TreeSet
Вам нужно заменить
TreeMap
, который вы возвращали при выводе результатов поиска на
TreeSet
и переписать все остальные методы так, чтобы проект компилировался.

Однако если вы запустите проект на данном этапе, то получите ошибку
ClassCastException
, так как классы, которые добавляются в поисковый движок, не реализуют интерфейс
Comparable
.

Шаг 2. Компаратор
Теперь нужно реализовать сортировку статей согласно условиям:

Статьи в результатах поиска должны выводиться, начиная от статьи с самым длинным именем и заканчивая статьей с самым коротким именем.
Если длина имен одинаковая, то статьи должны сортироваться в натуральном порядке.
Для этого вам понадобиться написать компаратор, который состоит из двух частей:

Получение длины имен и сравнение их через
Integer.compare
.
Если значение, которое вернул
Integer.compare == 0
, тогда нужно сравнивать имена, используя методы
compareTo
.
Результат, который возвращает наш компаратор, — это либо результат
Integer.compare
(если он не 0), либо результат сравнения имен через
compareTo
.

Проверьте, что результаты поиска сортируются в соответствии с этим компаратором. Попробуйте разные сценарии с разными результатами.

