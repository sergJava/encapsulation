Что нужно сделать
В этой домашней работе мы перепишем основные методы продуктовой корзины и поискового движка на Stream API.

Сделайте это задание в новой ветке «старого» проекта, где выполняли предыдущую домашнюю работу. Выполняйте задание строго по порядку. Пока не сделали предыдущий шаг — не приступайте к следующему.

1. Измените метод search в поисковом движке
   Метод
   search
   не должен использовать циклы — перепишите его одним стримом с использованием промежуточной операции
   filter
   и терминальной операции
   collect
   .

Так как результаты поиска мы возвращаем в виде
TreeSet
с собственным компаратором, то нужно использовать специальный коллектор
Collectors.toCollection(() → )
. Он принимает в себя функциональный интерфейс
Supplier<Collection>
, который создает нужную нам коллекцию.

Для этого напишите лямбда-выражение, которое реализует
Supplier
и возвращает нужный нам
TreeSet
с компаратором. В остальном цепочка будет похожа на изученную ранее цепочку
filter().collect()
.

После этого изменения проект должен компилироваться и иметь тот же самый вывод, что и до изменения.

2. Измените методы в классе ProductBasket
   В классах корзины вам нужно заменить циклы на StreamAPI. Сложность в том, что корзина хранит товары в виде
   Map<String, List<Product>>
   . Чтобы получить доступ к списку товаров, приходилось использовать вложенный цикл.

В StreamAPI для этого есть операция
flatMap
, которая превращает
Stream
из списков в плоский
Stream
, который содержит все продукты

products.values().stream().flatMap(Collection::stream)

После применения
flatMap
можно выполнять любые операции над продуктами так, как если бы они лежали в одном списке.

Рекомендации по переписыванию методов:

Метод, который возвращает полную стоимость корзины, нужно переписать используя операторы
mapToInt
и
sum
.
Метод печати корзины нужно переписать, используя метод
forEach
. Если в этом же методе вы считаете количество специальных продуктов, нужно выделить его в отдельный приватный метод
getSpecialCount
, который использует операции
filter
и
count
.
После этих изменений:

код должен компилироваться,
вывод — остаться таким же, как до изменений.