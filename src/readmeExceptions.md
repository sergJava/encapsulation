Что нужно сделать
В этой домашней работе вы продолжите работу над проектом интернет-магазина. На этот раз вам нужно будет:

реализовать проверки полей для создания товаров и статей, чтобы не было возможности создавать неправильные объекты,
расширить функциональность поиска по товарам и статьям.
Сделайте это задание в новой ветке «старого» проекта, где выполняли предыдущую домашнюю работу.

1. Реализация проверок в конструкторе класса Product
   Так как все классы наших продуктов унаследованы от
   Product
   , мы можем реализовать проверку данных только в нем.

В конструкторе класса
Product
реализуйте проверку названия по следующим условиям:

Название продукта не может быть пустой строкой или
null
. При этом пустая строка может быть также строкой, состоящей только из пробелов: в этом случае правило не выполняется, так как это неправильное название для продукта.

Подсказка

В конструкторе класса
SimpleProduct
реализуйте проверку передаваемой цены продукта, цена должна быть строго больше 0. Слово «строго» означает, что цена не включает в себя ноль, то есть должна быть 1 или выше.
В конструкторе класса
DiscountedProduct
реализуйте проверки базовой цены и процента скидки. Правила для базовой цены — такие же, как для цены в классе
SimpleProduct
. Правила для процента скидки — процент должен быть числом в диапазоне от 0 до 100 включительно. Слово «включительно» означает, что границы диапазона 0 и 100 тоже являются правильными значениями.
Проверки по этим условиям нужно добавить в конструкторы классов. Если условия не выполняются, вам нужно выбросить
IllegalArgumentException
с сообщением, в котором раскрыты детали о том, какое правило не сработало.

2. Демонстрация проверки данных в классе main
   Создайте несколько продуктов и нарочно заполните их поля неправильно.
   Затем обработайте
   IllegalArgumentException
   в блоках
   try
   и
   catch
   .
   В качестве обработки можно просто выводить сообщение из исключения.
3. Реализация метода поиска самого подходящего элемента
   Реализуйте в классе
   SearchEngine
   метод, который находит среди объектов
   Searchable
   наиболее подходящий к поисковой строке и возвращает его.
   Метод должен принимать строку
   search
   , а возвращать объект
   Searchable
   .
   Наиболее подходящим назовем объект типа
   Searchable
   . Его метод
   getSearchTerm()
   содержит максимальное количество повторов строки
   search
   . Если таких объектов несколько, то вернуть можно любой из них.


Подсказка
Чтобы найти максимальное количество повторений подстроки в строке, можно воспользоваться следующим алгоритмом.

//Алгоритм написан псевдокодом, и его идея в том, чтобы, используя операцию поиска индекса подстроки в строке посчитать количество
//Операция indexOf(substring, индекс) ищет первый подходящий индекс подстроки,
//начиная с индекса "индекс". Если она находит что-то, то
//индекс перемещается на длину подстроки и операция повторяется
//до тех пора, пока в оставшей строке нет больше вхождений нашей подстроки

str = "helloabcdehellonnnnnnhello"

substring = "hello"

количество = 0

индекс = 0

индексПодстроки = str.indexOf(substring, индекс)

while(индексПодстроки != -1){

количество++;

индекс = индекс + substring.length();

индексПодстроки = str.indexOf(substring, индекс)
}

4. Добавление исключений
   Мы не хотим, чтобы метод поиска наиболее подходящего объекта возвращал
   null
   , если такого объекта нет. Поэтому если объект не найден, вам нужно выбрасывать собственное исключение — назовите его
   BestResultNotFound
   .

Это исключение должно быть проверяемым, и в сообщении должно содержать информацию, для какого поискового запроса не нашлось подходящей статьи.

5. Демонстрация нового метода поиска
   Продемонстрируйте в методе
   main
   новый метод поиска в двух сценариях:

когда нужный объект существует,
когда метод выбрасывает исключение.
Обработайте исключение и выведите сообщения об ошибке.